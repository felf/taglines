#!/usr/bin/python3
# -*- coding: utf-8 -*-

# Preamble {{{1
""" Entry point for the Taglines program. """

import taglines
from taglines.ArgParser import ArgParser
from taglines.ShellUI import ShellUI

import os
from datetime import date

def init_database(filepath):  # {{{1
    """ create a new sqlite database file """

    if os.path.exists(filepath):
        ok = input("Warning: "+filepath+" already exists. Overwrite? [y/N] ")
        if ok and "yes".startswith(ok.lower()):
            try:
                os.remove(filepath)
            except OSError as e:
                exit("Error: could not delete old file: {}. Exiting.".format(
                     e.args[1]))
        else:
            print("good bye")
            exit(1)
    db = taglines.Database()
    db.initialiseFile(filepath)

def get_random_item(args):  # {{{1
    """ retrieve one random tagline """

    db = taglines.Database(args.file)
    if db:
        db.parseArguments(args)
        tl = db.randomTagline()
        if tl:
            print(tl)

def list_items(args):  # {{{1
    """ show list of taglines """

    db = taglines.Database(args.file)
    if db:
        db.parseArguments(args)

        first = True
        for r in db.taglines():
            if first:
                first = False
            else:
                print("%")
            print(r[0])

def show_tags(filepath):  # {{{1
    """ print all tags, sorted alphabetically """

    db = taglines.Database(filepath)
    if db:
        for tag in db.tags(orderByName=True):
            print(tag)


def show_authors(filepath):  # {{{1
    """ print all authors, sorted alphabetically """

    db = taglines.Database(filepath)
    if db:
        for author in db.authors():
            print(author)

def show_stats(filepath):  # {{{1
    """ print tabular statistics about the given database file """

    db = taglines.Database(filepath)
    if db:
        stats = db.stats()

        print("Number of taglines:        {:6d}".format(stats["tagline count"],))
        print("Number of texts:           {:6d}   (ø {:5.2f} per tagline)".format(
            stats["line count"], stats["line count"]/stats["tagline count"]))
        print("Average text length:       {:8.1f}".format(stats["avg tagline length"],))
        print("Number of tags:            {:6d}".format(stats["tag count"],))
        print("Number of tag assignments: {:6d}   (ø {:5.2f} per tagline)".format(
            stats["tag assignments"], stats["tag assignments"]/stats["tagline count"]))
        print("Number of authors:         {:6d}".format(stats["author count"],))
        print("Used languages:            {:6d}".format(stats["language count"],))
        exit(0)

def interactive_menu(filepath):  # {{{1
    """ start interactive console menu mode and exit at the end """

    try:
        db = taglines.Database(filepath)
        if db:
            shell = ShellUI(db)
        shell.mainMenu()
    except Exception as e:
        print(sys.exc_info()[1])
        exit(1)
    exit(0)


if __name__ == "__main__":  # {{{1
    parser = ArgParser()
    args = parser.args

    if args.init:
        init_database(args.file)
        exit(0)

    if args.random:
        ret_random_item(args)
        exit(0)

    if args.list:
        list_items(args)
        exit(0)

    if args.show_tags:
        show_tags(args.file)
        exit(0)

    if args.show_authors:
        show_authors(args.file)
        exit(0)

    if args.stats:
        show_stats(args.file)
        exit(0)

    if args.interactive:
        interactive_menu(args.file)

    if args.graphical or not sys.stdin.isatty():  # {{{2
        # imports {{{3
        try:
            from PyQt4 import QtGui,QtCore
            from PyQt4.QtGui import *
            from PyQt4.QtCore import *
        except ImportError:
            print "PyQt modules not found.  Cannot start graphical interface."
            exit(1)
        try:
            # if available, replace Qt file dialogues with the more sophisticated KDE version
            from PyKDE4.kio import KFileDialog
            kde = True
    #       from PyKDE4.kdecore import *
        except ImportError:
            kde = False
            pass

        class AuthorModel(QAbstractItemModel): #{{{3
            """
            This class is the interface to the authors in the database

            It allows to select one and only one author for a tagline.
            """
            def __init__(self, parent=None):
                QAbstractItemModel.__init__(self, parent)
                self.setHeaderData(0, Qt.Horizontal, QtCore.QVariant("Name"), Qt.DisplayRole)
                self.setHeaderData(1, Qt.Horizontal, QtCore.QVariant("Born"), Qt.DisplayRole)
                self.setHeaderData(2, Qt.Horizontal, QtCore.QVariant("Died"), Qt.DisplayRole)
                self.authors=[
                    (-2, u'(Don\'t filter)', None, None),
                    (-1, u'(None)', None, None)]
            def setDB(self, db):
                self.db = db
                self.authors=[
                    (-2, u'(Don\'t filter)', None, None),
                    (-1, u'(None)', None, None)]
                c = self.db.cursor()
                c.execute("SELECT * FROM authors ORDER BY name")
                for r in c:
                    self.authors.append(r)
                self.emit(SIGNAL("dataChanged()"))
            def data(self, index, role=Qt.DisplayRole):
                if role!=Qt.DisplayRole: return QVariant(QVariant.Invalid)
                if not index.isValid(): return QVariant(QVariant.Invalid)
                author = self.authors[index.row()]
                return author[index.column()]
            def hasChildren(self, index):
                return False;
            def index(self, row, column, parent=QModelIndex()):
                if row>=len(self.authors) or row<0 or column<0 or column>3:
                    return QModelIndex()
                return self.createIndex(row, column, self.authors[row]);
            def parent(self, index):
                return QModelIndex()
            def columnCount(self, parent=QModelIndex()):
                return 4
            def rowCount(self, parent=QModelIndex()):
                return len(self.authors)
            def setData(self, index, value, role=Qt.EditRole):
                if not index.isValid(): return False
                if role!=Qt.CheckEditRole: return False
                author=self.authors[index.row()]
                c = self.db.cursor()
                if index.column()==0:
                    self.authors[index.row()][0]=value;
                    c.execute("UPDATE authors SET name = '" + value +
                        "' WHERE id = '" + index.row() + "'")
                else:
                    i="" if value=="" else int(value)
                    self.authors[index.row()][index.column()]=i;
                    c.execute("UPDATE authors SET " +
                        ("born" if index.column()==1 else "died") +
                        " = '" + value + "' WHERE id = '" + index.row() + "'")
                self.emit(SIGNAL("dataChanged()"))
                return True

        class LanguagesModel(QAbstractItemModel): #{{{3
            """
            This class is the interface to the languages in the database

            It allows to select a number of languages for a tagline.
            """
            def __init__(self, parent=None):
                QAbstractItemModel.__init__(self, parent)
                self.setHeaderData(0, Qt.Horizontal, QtCore.QVariant("Name"), Qt.DisplayRole)

            def setDB(self, db):
                self.db = db
                self.languages=[]
                c = self.db.cursor()
                c.execute("SELECT DISTINCT language FROM lines")
                for r in c:
                    self.languages.append(list(r)+[False])
                self.emit(SIGNAL("dataChanged()"))
            def data(self, index, role=Qt.DisplayRole):
                if not index.isValid(): return QVariant(QVariant.Invalid)
                language = self.languages[index.row()]
                if index.column()==0 and role==Qt.CheckStateRole:
                    return language[1]
                if role!=Qt.DisplayRole: return QVariant(QVariant.Invalid)
                return language[index.column()]
            def flags(self, index):
                if not index.isValid(): return Qt.NoItemFlags
                return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsUserCheckable
            def hasChildren(self, index):
                return False;
            def index(self, row, column, parent=QModelIndex()):
                if row>=len(self.languages) or row<0 or column<0 or column>2:
                    return QModelIndex()
                return self.createIndex(row, column, self.languages[row]);
            def parent(self, index):
                return QModelIndex()
            def columnCount(self, parent=QModelIndex()):
                return 1
            def rowCount(self, parent=QModelIndex()):
                return len(self.languages)
            def setData(self, index, value, role=Qt.EditRole):
                if not index.isValid(): return False
                lang=self.languages[index.row()]
                if role==Qt.CheckStateRole:
                    lang[1] = value
                    return True
                return False

        class TagsModel(QAbstractItemModel): #{{{3
            """
            This class is the interface to the tags in the database

            It allows to select a number of tags for a tagline.
            """
            def __init__(self, parent=None):
                QAbstractItemModel.__init__(self, parent)
                self.setHeaderData(0, Qt.Horizontal, QtCore.QVariant("Name"), Qt.DisplayRole)

            def setDB(self, db):
                self.db = db
                self.tags=[]
                c = self.db.cursor()
                c.execute("SELECT * FROM tags ORDER BY text")
                for r in c:
                    self.tags.append(list(r)+[False])
                self.emit(SIGNAL("dataChanged()"))
            def data(self, index, role=Qt.DisplayRole):
                if not index.isValid(): return QVariant(QVariant.Invalid)
                tag = self.tags[index.row()]
                if index.column()==1 and role==Qt.CheckStateRole:
                    return tag[2]
                if role!=Qt.DisplayRole: return QVariant(QVariant.Invalid)
                return tag[index.column()]
            def flags(self, index):
                if not index.isValid(): return Qt.NoItemFlags
                f = Qt.ItemIsEnabled | Qt.ItemIsSelectable
                if index.column()==1: f |= Qt.ItemIsUserCheckable
                return f
            def hasChildren(self, index):
                return False;
            def index(self, row, column, parent=QModelIndex()):
                if row>=len(self.tags) or row<0 or column<0 or column>2:
                    return QModelIndex()
                return self.createIndex(row, column, self.tags[row]);
            def parent(self, index):
                return QModelIndex()
            def columnCount(self, parent=QModelIndex()):
                return 2
            def rowCount(self, parent=QModelIndex()):
                return len(self.tags)
            def setData(self, index, value, role=Qt.EditRole):
                if not index.isValid(): return False
                tag=self.tags[index.row()]
                if role==Qt.CheckStateRole:
                    tag[2] = value
                    return True
                if index.column()==1:
                    self.tags[index.row()][1]=value
                    c = self.db.cursor()
                    c.execute("UPDATE tags SET text = '" + value +
                        "' WHERE id = '" + index.row() + "'")
                return True

        class TaglinesWindow(QMainWindow): #{{{3
            def __init__(self):
                QMainWindow.__init__(self)
                self.resize(800,600)
                self.setWindowTitle('Taglines database')

                self.authors = AuthorModel(self)
                self.languages = LanguagesModel(self)
                self.tags = TagsModel(self)

                # Create actions
                newAction = QAction('New database', self)
                openAction = QAction('Open database', self)
                saveAction = QAction('Save database', self)
                saveAsAction = QAction('Save database as', self)
                exitAction = QAction('Exit', self)
                editAction = QAction('Edit Phrase Pairs', self)

                newAction.setShortcut('Ctrl+N')
                openAction.setShortcut('Ctrl+O')
                saveAction.setShortcut('Ctrl+S')
                saveAsAction.setShortcut('Ctrl+Shift+S')
                exitAction.setShortcut('Ctrl+Q')

                newAction.setIcon(QIcon.fromTheme("document-new"))
                openAction.setIcon(QIcon.fromTheme("document-open"))
                saveAction.setIcon(QIcon.fromTheme("document-save"))
                saveAsAction.setIcon(QIcon.fromTheme("document-save-as"))
                exitAction.setIcon(QIcon.fromTheme("application-exit"))

                # Connect actions
                #self.connect(newAction, SIGNAL('triggered()'), self.newFile)
                self.connect(openAction, SIGNAL('triggered()'), self.openFile)
                #self.connect(saveAction, SIGNAL('triggered()'), self.saveFile)
                #self.connect(saveAsAction, SIGNAL('triggered()'), self.saveFileAs)
                self.connect(exitAction, SIGNAL('triggered()'), SLOT('close()'))

                # Create menubar with actions
                menubar = self.menuBar()
                filemenu = menubar.addMenu('&File')
                filemenu.addAction(newAction)
                filemenu.addAction(openAction)
                filemenu.addSeparator()
                filemenu.addAction(saveAction)
                filemenu.addAction(saveAsAction)
                filemenu.addSeparator()
                filemenu.addAction(exitAction)

                mainSplitter = QSplitter(Qt.Horizontal, self)
                rightSplitter = QSplitter(Qt.Vertical, self)
                sidebarSplitter = QSplitter(Qt.Vertical, self)

                sidebar = QWidget()
                sidebarLayout = QVBoxLayout()
                sidebar.setLayout(sidebarLayout)
                sidebarLayout.addWidget(QLabel('Author:'))
                self.AuthorList = QComboBox()
                self.AuthorList.setModel(self.authors)
                self.AuthorList.setModelColumn(1)
                sidebarLayout.addWidget(self.AuthorList)

                sidebarLayout.addWidget(QLabel('Languages:'))
                self.LangList = QListView()
                self.LangList.setModel(self.languages)
                self.LangList.setModelColumn(1)
                sidebarLayout.addWidget(self.LangList)

                sidebarSplitter.addWidget(sidebar)

                sidebar = QWidget()
                sidebarLayout = QVBoxLayout()
                sidebar.setLayout(sidebarLayout)

                sidebarLayout.addWidget(QLabel('Tags:'))
                self.TagList = QListView()
                self.TagList.setModel(self.tags)
                self.TagList.setModelColumn(1)
                sidebarLayout.addWidget(self.TagList)

                sidebarSplitter.addWidget(sidebar)
                mainSplitter.addWidget(sidebarSplitter)

                sidebarSplitter.setStretchFactor(0, 0)
                sidebarSplitter.setStretchFactor(1, 1)

                self.TaglinesWidget = QListWidget(self)
                self.LinesWidget = QListWidget(self)
                rightSplitter.addWidget(self.TaglinesWidget)
                rightSplitter.addWidget(self.LinesWidget)
                rightSplitter.setStretchFactor(0, 1)
                rightSplitter.setStretchFactor(1, 0)

                mainSplitter.addWidget(rightSplitter)
                mainSplitter.setStretchFactor(0, 0)
                mainSplitter.setStretchFactor(1, 1)
                self.setCentralWidget(mainSplitter)

                self.db = None
                if args.file: self.loadFile(args.file)

            def closeFile(self):
                if self.db: self.db.close()
                return True
            def loadFile(self, url):
                    if not self.closeFile():
                        return False
                    try:
                        self.db = get_database_from_file(str(url))
                        self.TaglinesWidget.clear()
                        self.LinesWidget.clear()

                        self.authors.setDB(self.db)
                        self.languages.setDB(self.db)
                        self.tags.setDB(self.db)

                    #except InvalidFileError:
                    #    QMessageBox.warning(None, "Error", "This file is not a taglines database.")
                    #    return False
                    except IOError:
                        QMessageBox.critical(self, "Error", "An error occured while reading the file.")
                        return False
            def openFile(self):
                if kde:
                    url = QFileDialog.getOpenFileName(
                        self, 'Open a taglines database', '',
                        'SQLite-Database (*.sqlite)\n*.*|All Files')
                else:
                    url = KFileDialog.getOpenFileName(
                        KUrl(), 'SQLite-Database (*.sqlite)\n*.*|All Files',
                        self, 'Open a taglines database')

                if url!='':
                    self.loadFile(url)
        #}}}2

        app = QApplication(sys.argv)
        mainwindow = TaglinesWindow()
        mainwindow.show()
        sys.exit(app.exec_())
